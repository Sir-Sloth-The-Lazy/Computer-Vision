# -*- coding: utf-8 -*-
"""Linear_NN_for_Images

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Xa67-QNHzeC9i_ZEaEoRenFjPm036Dl3
"""

import tensorflow as tf
IMG_HEIGHT = 224
IMG_WIDTH = 224
IMG_CHANNELS = 3

CLASS_NAMES = ["daisy" , "dandelion" , "roses" , "sunflower" , "tulips"]


def read_and_decode(filename , resize_dims):
  # read the raw files
  img_bytes = tf.io.read_file(filename)
  # Decode the image data in RGB channels from the jpeg format
  img = tf.image.decode_jpeg(img_bytes , channels = IMG_CHANNELS)
  # convert the pixel values (0-255) to between (0-1)
  img = tf.image.convert_image_dtype(img, tf.float32)
  # resize the images to match a uniform demensions to input into the neural networks
  img = tf.image.resize(img , resize_dims)
  return img




# Function to parse CSV line
def parse_csvline(csv_line):
    # Define the defaults in case of missing values
    record_defaults = ["", ""]

    # Decode the CSV line into filename and label_string
    filename, label_string = tf.io.decode_csv(csv_line, record_defaults)

    # Load the image
    img = read_and_decode(filename, [IMG_HEIGHT, IMG_WIDTH])

    # Convert the label string to an integer index based on CLASS_NAMES
    label = tf.argmax(tf.math.equal(CLASS_NAMES, label_string), axis=-1)

    return img, label

train_dataset = (
    tf.data.TextLineDataset("gs://cloud-ml-data/img/flower_photos/train_set.csv")
    .map(parse_csvline , num_parallel_calls=tf.data.AUTOTUNE)
    .batch(16)
    .prefetch(tf.data.AUTOTUNE)
)
eval_dataset = (
    tf.data.TextLineDataset("gs://cloud-ml-data/img/flower_photos/eval_set.csv") # replace spaces with '%20'
    .map(parse_csvline , num_parallel_calls=tf.data.AUTOTUNE)
    .batch(16)
    .prefetch(tf.data.AUTOTUNE)
)
for image_batch , label_batch in train_dataset.take(1):
  print("Image batch shape : ", image_batch.shape)
  print("Label batch shape : ", label_batch.shape)
  print("Labels:" , label_batch.numpy())

import matplotlib.pyplot as plt

for image_batch, label_batch in train_dataset.take(2):
  first_image = image_batch[0]
  first_label = label_batch[0]

  plt.imshow(first_image.numpy()) # convert the tensor to numpy array
  plt.title(f"Label : {CLASS_NAMES[first_label]}")
  plt.axis('off')
  plt.show()

import matplotlib.pyplot as plt

for image_batch , label_batch in train_dataset.take(1):
  fig, axes = plt.subplots(4 , 4, figsize=(10,10)) # create a grid of size 4 X 4

  for i in range(16) :
    ax = axes[i // 4, i % 4] # Determine the position in the grid like if i = 1 ; (x,y) =  (1//4 = 0 , i % 4 = 1) if i = 4 it will print in next line then
    ax.imshow(image_batch[i].numpy()) # convert the tensor into a numpy image
    ax.set_title(f"Label: {CLASS_NAMES[label_batch[i]]}")
    ax.axis("off") # Hide axis

  plt.tight_layout()
  plt.show()

from tensorflow import keras

model = keras.Sequential([
    keras.layers.Flatten(input_shape=(IMG_HEIGHT, IMG_WIDTH, IMG_CHANNELS)),
    keras.layers.Dense(len(CLASS_NAMES) , activation="softmax")
])

model.compile(
    optimizer="adam",
    loss = keras.losses.SparseCategoricalCrossentropy(from_logits=False),
    metrics=["accuracy"]
)

EPOCHS = 10
history = model.fit(
    train_dataset,
    validation_data = eval_dataset,
    epochs = EPOCHS
)

import matplotlib.pyplot as plt

plt.plot(history.history["loss"] , label = "Training Loss")
plt.plot(history.history["val_loss"] , label = "Validation Loss")
plt.xlabel("Epochs")
plt.ylabel("Loss")
plt.legend()
plt.show()

import numpy as np
import matplotlib.pyplot as plt
import math

# Take a batch from the evaluation dataset to test the model's prediction
for images , labels in eval_dataset.take(1):
  batch_prediction = model.predict(images)
  predicted_indices = np.argmax(batch_prediction , axis = 1)

  num_images = images.shape[0]

  # configure the number of images to display per row
  num_cols = 4
  num_rows = math.ceil(num_images / num_cols)

  # create a figure with a suitable size
  plt.figure(figsize=(12 , 3 * num_rows))

  for i in range(num_images):
    plt.subplot(num_rows , num_cols , i+1)
    plt.imshow(images[i].numpy())
    plt.axis('off')

    pred_class = CLASS_NAMES[predicted_indices[i]]
    actual_class = CLASS_NAMES[labels[i].numpy()]
    plt.title(f"Pred: {pred_class} \n Actual: {actual_class}" , fontsize =10)

  plt.tight_layout()
  plt.show()